Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    LPAREN
    RPAREN

Grammar

Rule 0     S' -> Program
Rule 1     Program -> ExpressionList
Rule 2     ExpressionList -> <empty>
Rule 3     ExpressionList -> Expression
Rule 4     ExpressionList -> Expression ExpressionList
Rule 5     Expression -> ID
Rule 6     Expression -> Expression BinaryOp Expression
Rule 7     BinaryOp -> ARROW
Rule 8     BinaryOp -> CONJ
Rule 9     BinaryOp -> DISJ
Rule 10    BinaryOp -> NOT

Terminals, with rules where they appear

ARROW                : 7
CONJ                 : 8
DISJ                 : 9
ID                   : 5
LPAREN               : 
NOT                  : 10
RPAREN               : 
error                : 

Nonterminals, with rules where they appear

BinaryOp             : 6
Expression           : 3 4 6 6
ExpressionList       : 1 4
Program              : 0

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . ExpressionList
    (2) ExpressionList -> .
    (3) ExpressionList -> . Expression
    (4) ExpressionList -> . Expression ExpressionList
    (5) Expression -> . ID
    (6) Expression -> . Expression BinaryOp Expression

    $end            reduce using rule 2 (ExpressionList -> .)
    ID              shift and go to state 4

    Program                        shift and go to state 1
    ExpressionList                 shift and go to state 2
    Expression                     shift and go to state 3

state 1

    (0) S' -> Program .



state 2

    (1) Program -> ExpressionList .

    $end            reduce using rule 1 (Program -> ExpressionList .)


state 3

    (3) ExpressionList -> Expression .
    (4) ExpressionList -> Expression . ExpressionList
    (6) Expression -> Expression . BinaryOp Expression
    (2) ExpressionList -> .
    (3) ExpressionList -> . Expression
    (4) ExpressionList -> . Expression ExpressionList
    (7) BinaryOp -> . ARROW
    (8) BinaryOp -> . CONJ
    (9) BinaryOp -> . DISJ
    (10) BinaryOp -> . NOT
    (5) Expression -> . ID
    (6) Expression -> . Expression BinaryOp Expression

  ! reduce/reduce conflict for $end resolved using rule 2 (ExpressionList -> .)
    $end            reduce using rule 2 (ExpressionList -> .)
    ARROW           shift and go to state 7
    CONJ            shift and go to state 8
    DISJ            shift and go to state 9
    NOT             shift and go to state 10
    ID              shift and go to state 4

  ! $end            [ reduce using rule 3 (ExpressionList -> Expression .) ]

    Expression                     shift and go to state 3
    ExpressionList                 shift and go to state 5
    BinaryOp                       shift and go to state 6

state 4

    (5) Expression -> ID .

    ARROW           reduce using rule 5 (Expression -> ID .)
    CONJ            reduce using rule 5 (Expression -> ID .)
    DISJ            reduce using rule 5 (Expression -> ID .)
    NOT             reduce using rule 5 (Expression -> ID .)
    ID              reduce using rule 5 (Expression -> ID .)
    $end            reduce using rule 5 (Expression -> ID .)


state 5

    (4) ExpressionList -> Expression ExpressionList .

    $end            reduce using rule 4 (ExpressionList -> Expression ExpressionList .)


state 6

    (6) Expression -> Expression BinaryOp . Expression
    (5) Expression -> . ID
    (6) Expression -> . Expression BinaryOp Expression

    ID              shift and go to state 4

    Expression                     shift and go to state 11

state 7

    (7) BinaryOp -> ARROW .

    ID              reduce using rule 7 (BinaryOp -> ARROW .)


state 8

    (8) BinaryOp -> CONJ .

    ID              reduce using rule 8 (BinaryOp -> CONJ .)


state 9

    (9) BinaryOp -> DISJ .

    ID              reduce using rule 9 (BinaryOp -> DISJ .)


state 10

    (10) BinaryOp -> NOT .

    ID              reduce using rule 10 (BinaryOp -> NOT .)


state 11

    (6) Expression -> Expression BinaryOp Expression .
    (6) Expression -> Expression . BinaryOp Expression
    (7) BinaryOp -> . ARROW
    (8) BinaryOp -> . CONJ
    (9) BinaryOp -> . DISJ
    (10) BinaryOp -> . NOT

  ! shift/reduce conflict for ARROW resolved as shift
  ! shift/reduce conflict for CONJ resolved as shift
  ! shift/reduce conflict for DISJ resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    ID              reduce using rule 6 (Expression -> Expression BinaryOp Expression .)
    $end            reduce using rule 6 (Expression -> Expression BinaryOp Expression .)
    ARROW           shift and go to state 7
    CONJ            shift and go to state 8
    DISJ            shift and go to state 9
    NOT             shift and go to state 10

  ! ARROW           [ reduce using rule 6 (Expression -> Expression BinaryOp Expression .) ]
  ! CONJ            [ reduce using rule 6 (Expression -> Expression BinaryOp Expression .) ]
  ! DISJ            [ reduce using rule 6 (Expression -> Expression BinaryOp Expression .) ]
  ! NOT             [ reduce using rule 6 (Expression -> Expression BinaryOp Expression .) ]

    BinaryOp                       shift and go to state 6
WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ARROW in state 11 resolved as shift
WARNING: shift/reduce conflict for CONJ in state 11 resolved as shift
WARNING: shift/reduce conflict for DISJ in state 11 resolved as shift
WARNING: shift/reduce conflict for NOT in state 11 resolved as shift
WARNING: reduce/reduce conflict in state 3 resolved using rule (ExpressionList -> <empty>)
WARNING: rejected rule (ExpressionList -> Expression) in state 3
WARNING: Rule (ExpressionList -> Expression) is never reduced
