Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> Program
Rule 1     Program -> ExpressionList
Rule 2     ExpressionList -> Expression
Rule 3     ExpressionList -> Expression ExpressionList
Rule 4     Expression -> ID
Rule 5     Expression -> Expression BinaryOp Expression
Rule 6     Expression -> UnaryOp Expression
Rule 7     Expression -> LPAREN Expression RPAREN
Rule 8     BinaryOp -> ARROW
Rule 9     BinaryOp -> CONJ
Rule 10    BinaryOp -> DISJ
Rule 11    UnaryOp -> NOT

Terminals, with rules where they appear

ARROW                : 8
CONJ                 : 9
DISJ                 : 10
ID                   : 4
LPAREN               : 7
NOT                  : 11
RPAREN               : 7
error                : 

Nonterminals, with rules where they appear

BinaryOp             : 5
Expression           : 2 3 5 5 6 7
ExpressionList       : 1 3
Program              : 0
UnaryOp              : 6

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . ExpressionList
    (2) ExpressionList -> . Expression
    (3) ExpressionList -> . Expression ExpressionList
    (4) Expression -> . ID
    (5) Expression -> . Expression BinaryOp Expression
    (6) Expression -> . UnaryOp Expression
    (7) Expression -> . LPAREN Expression RPAREN
    (11) UnaryOp -> . NOT

    ID              shift and go to state 4
    LPAREN          shift and go to state 6
    NOT             shift and go to state 7

    Program                        shift and go to state 1
    ExpressionList                 shift and go to state 2
    Expression                     shift and go to state 3
    UnaryOp                        shift and go to state 5

state 1

    (0) S' -> Program .



state 2

    (1) Program -> ExpressionList .

    $end            reduce using rule 1 (Program -> ExpressionList .)


state 3

    (2) ExpressionList -> Expression .
    (3) ExpressionList -> Expression . ExpressionList
    (5) Expression -> Expression . BinaryOp Expression
    (2) ExpressionList -> . Expression
    (3) ExpressionList -> . Expression ExpressionList
    (8) BinaryOp -> . ARROW
    (9) BinaryOp -> . CONJ
    (10) BinaryOp -> . DISJ
    (4) Expression -> . ID
    (5) Expression -> . Expression BinaryOp Expression
    (6) Expression -> . UnaryOp Expression
    (7) Expression -> . LPAREN Expression RPAREN
    (11) UnaryOp -> . NOT

    $end            reduce using rule 2 (ExpressionList -> Expression .)
    ARROW           shift and go to state 10
    CONJ            shift and go to state 11
    DISJ            shift and go to state 12
    ID              shift and go to state 4
    LPAREN          shift and go to state 6
    NOT             shift and go to state 7

    Expression                     shift and go to state 3
    ExpressionList                 shift and go to state 8
    BinaryOp                       shift and go to state 9
    UnaryOp                        shift and go to state 5

state 4

    (4) Expression -> ID .

    ARROW           reduce using rule 4 (Expression -> ID .)
    CONJ            reduce using rule 4 (Expression -> ID .)
    DISJ            reduce using rule 4 (Expression -> ID .)
    ID              reduce using rule 4 (Expression -> ID .)
    LPAREN          reduce using rule 4 (Expression -> ID .)
    NOT             reduce using rule 4 (Expression -> ID .)
    $end            reduce using rule 4 (Expression -> ID .)
    RPAREN          reduce using rule 4 (Expression -> ID .)


state 5

    (6) Expression -> UnaryOp . Expression
    (4) Expression -> . ID
    (5) Expression -> . Expression BinaryOp Expression
    (6) Expression -> . UnaryOp Expression
    (7) Expression -> . LPAREN Expression RPAREN
    (11) UnaryOp -> . NOT

    ID              shift and go to state 4
    LPAREN          shift and go to state 6
    NOT             shift and go to state 7

    UnaryOp                        shift and go to state 5
    Expression                     shift and go to state 13

state 6

    (7) Expression -> LPAREN . Expression RPAREN
    (4) Expression -> . ID
    (5) Expression -> . Expression BinaryOp Expression
    (6) Expression -> . UnaryOp Expression
    (7) Expression -> . LPAREN Expression RPAREN
    (11) UnaryOp -> . NOT

    ID              shift and go to state 4
    LPAREN          shift and go to state 6
    NOT             shift and go to state 7

    Expression                     shift and go to state 14
    UnaryOp                        shift and go to state 5

state 7

    (11) UnaryOp -> NOT .

    ID              reduce using rule 11 (UnaryOp -> NOT .)
    LPAREN          reduce using rule 11 (UnaryOp -> NOT .)
    NOT             reduce using rule 11 (UnaryOp -> NOT .)


state 8

    (3) ExpressionList -> Expression ExpressionList .

    $end            reduce using rule 3 (ExpressionList -> Expression ExpressionList .)


state 9

    (5) Expression -> Expression BinaryOp . Expression
    (4) Expression -> . ID
    (5) Expression -> . Expression BinaryOp Expression
    (6) Expression -> . UnaryOp Expression
    (7) Expression -> . LPAREN Expression RPAREN
    (11) UnaryOp -> . NOT

    ID              shift and go to state 4
    LPAREN          shift and go to state 6
    NOT             shift and go to state 7

    Expression                     shift and go to state 15
    UnaryOp                        shift and go to state 5

state 10

    (8) BinaryOp -> ARROW .

    ID              reduce using rule 8 (BinaryOp -> ARROW .)
    LPAREN          reduce using rule 8 (BinaryOp -> ARROW .)
    NOT             reduce using rule 8 (BinaryOp -> ARROW .)


state 11

    (9) BinaryOp -> CONJ .

    ID              reduce using rule 9 (BinaryOp -> CONJ .)
    LPAREN          reduce using rule 9 (BinaryOp -> CONJ .)
    NOT             reduce using rule 9 (BinaryOp -> CONJ .)


state 12

    (10) BinaryOp -> DISJ .

    ID              reduce using rule 10 (BinaryOp -> DISJ .)
    LPAREN          reduce using rule 10 (BinaryOp -> DISJ .)
    NOT             reduce using rule 10 (BinaryOp -> DISJ .)


state 13

    (6) Expression -> UnaryOp Expression .
    (5) Expression -> Expression . BinaryOp Expression
    (8) BinaryOp -> . ARROW
    (9) BinaryOp -> . CONJ
    (10) BinaryOp -> . DISJ

  ! shift/reduce conflict for ARROW resolved as shift
  ! shift/reduce conflict for CONJ resolved as shift
  ! shift/reduce conflict for DISJ resolved as shift
    ID              reduce using rule 6 (Expression -> UnaryOp Expression .)
    LPAREN          reduce using rule 6 (Expression -> UnaryOp Expression .)
    NOT             reduce using rule 6 (Expression -> UnaryOp Expression .)
    $end            reduce using rule 6 (Expression -> UnaryOp Expression .)
    RPAREN          reduce using rule 6 (Expression -> UnaryOp Expression .)
    ARROW           shift and go to state 10
    CONJ            shift and go to state 11
    DISJ            shift and go to state 12

  ! ARROW           [ reduce using rule 6 (Expression -> UnaryOp Expression .) ]
  ! CONJ            [ reduce using rule 6 (Expression -> UnaryOp Expression .) ]
  ! DISJ            [ reduce using rule 6 (Expression -> UnaryOp Expression .) ]

    BinaryOp                       shift and go to state 9

state 14

    (7) Expression -> LPAREN Expression . RPAREN
    (5) Expression -> Expression . BinaryOp Expression
    (8) BinaryOp -> . ARROW
    (9) BinaryOp -> . CONJ
    (10) BinaryOp -> . DISJ

    RPAREN          shift and go to state 16
    ARROW           shift and go to state 10
    CONJ            shift and go to state 11
    DISJ            shift and go to state 12

    BinaryOp                       shift and go to state 9

state 15

    (5) Expression -> Expression BinaryOp Expression .
    (5) Expression -> Expression . BinaryOp Expression
    (8) BinaryOp -> . ARROW
    (9) BinaryOp -> . CONJ
    (10) BinaryOp -> . DISJ

  ! shift/reduce conflict for ARROW resolved as shift
  ! shift/reduce conflict for CONJ resolved as shift
  ! shift/reduce conflict for DISJ resolved as shift
    ID              reduce using rule 5 (Expression -> Expression BinaryOp Expression .)
    LPAREN          reduce using rule 5 (Expression -> Expression BinaryOp Expression .)
    NOT             reduce using rule 5 (Expression -> Expression BinaryOp Expression .)
    $end            reduce using rule 5 (Expression -> Expression BinaryOp Expression .)
    RPAREN          reduce using rule 5 (Expression -> Expression BinaryOp Expression .)
    ARROW           shift and go to state 10
    CONJ            shift and go to state 11
    DISJ            shift and go to state 12

  ! ARROW           [ reduce using rule 5 (Expression -> Expression BinaryOp Expression .) ]
  ! CONJ            [ reduce using rule 5 (Expression -> Expression BinaryOp Expression .) ]
  ! DISJ            [ reduce using rule 5 (Expression -> Expression BinaryOp Expression .) ]

    BinaryOp                       shift and go to state 9

state 16

    (7) Expression -> LPAREN Expression RPAREN .

    ARROW           reduce using rule 7 (Expression -> LPAREN Expression RPAREN .)
    CONJ            reduce using rule 7 (Expression -> LPAREN Expression RPAREN .)
    DISJ            reduce using rule 7 (Expression -> LPAREN Expression RPAREN .)
    ID              reduce using rule 7 (Expression -> LPAREN Expression RPAREN .)
    LPAREN          reduce using rule 7 (Expression -> LPAREN Expression RPAREN .)
    NOT             reduce using rule 7 (Expression -> LPAREN Expression RPAREN .)
    $end            reduce using rule 7 (Expression -> LPAREN Expression RPAREN .)
    RPAREN          reduce using rule 7 (Expression -> LPAREN Expression RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ARROW in state 13 resolved as shift
WARNING: shift/reduce conflict for CONJ in state 13 resolved as shift
WARNING: shift/reduce conflict for DISJ in state 13 resolved as shift
WARNING: shift/reduce conflict for ARROW in state 15 resolved as shift
WARNING: shift/reduce conflict for CONJ in state 15 resolved as shift
WARNING: shift/reduce conflict for DISJ in state 15 resolved as shift
